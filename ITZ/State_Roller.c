#pragma config(Motor,  port2,           driveLeft,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           driveRight,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           mogo,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           Arm_LT_BR,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           Arm_RT_BL,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armClaw,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           armBox,        tmotorVex393_MC29, openLoop)


//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*               Desc: VEX 42627G Team Digital Minds Copyright               */
/*                    						Credit:																		 */
/*                    Head Developers: Mukul Rao, Jeffrey Tu				         */
/*                                    									                     */
/*                    				                                               */
/*                                                                           */
/*                                                                           */
/*     Filter Function/deadzone filter credit: Kaushik from 315 Paradigm,    */
/*                        as well as some other ideas.                       */
/*---------------------------------------------------------------------------*/

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

const short rightButton = 4;
const short centerButton = 2;
int autonomousOption = -1;

//Wait for Press--------------------------------------------------
void waitForPress()
{
	while(true){
		if(nLCDButtons == rightButton || nLCDButtons == centerButton) {
			break;
		}
	}
	wait1Msec(5);
}
//----------------------------------------------------------------

//Wait for Release------------------------------------------------
void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------

void clearAndDisplayLCD(const char* str) {
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDCenteredString(0, str);
}

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/
void pre_auton(){
	int currentOption = 0;
	// Enable LCD Display.
	bLCDBacklight = true;
	//clearing existing LCD text
	clearLCDLine(0);
	clearLCDLine(1);

	// By default disable auton.
	autonomousOption = 4;

	// Go into auton selection only if button 7R is held during boot.
	// This allows us to proceed to driver mode if Robot were to
	// get disconnected during a match.
	if(vexRT[Btn7R] == 1){
		bool optionSelected = false;
		while(!optionSelected){
			switch(currentOption){
			case 0:
				displayLCDCenteredString(0, "Left Auton");
				displayLCDCenteredString(1, "Enter ==>");
				waitForPress();
				if(nLCDButtons == centerButton){
					waitForRelease();
					optionSelected = true;
					autonomousOption = 0;
					clearAndDisplayLCD("Left Auton");
					} else if(nLCDButtons == rightButton){
					waitForRelease();
					currentOption++;
				}
				break;
			case 1:
				displayLCDCenteredString(0, "Right Auton");
				displayLCDCenteredString(1, "Enter ==>");
				waitForPress();
				if(nLCDButtons == centerButton){
					waitForRelease();
					optionSelected = true;
					autonomousOption = 1;
					clearAndDisplayLCD("Right Auton");
					} else if(nLCDButtons == rightButton){
					waitForRelease();
					currentOption++;
				}
				break;
			case 2:
				displayLCDCenteredString(0, "Static Auton");
				displayLCDCenteredString(1, "Enter ==>");
				waitForPress();
				if(nLCDButtons == centerButton){
					waitForRelease();
					optionSelected = true;
					autonomousOption = 2;
					clearAndDisplayLCD("Static Auton");
					} else if(nLCDButtons == rightButton){
					waitForRelease();
					currentOption++;
				}
				break;
			case 3:
				displayLCDCenteredString(0, "Skills Auton");
				displayLCDCenteredString(1, "Enter ==>");
				waitForPress();
				if(nLCDButtons == centerButton){
					waitForRelease();
					optionSelected = true;
					autonomousOption = 3;
					clearAndDisplayLCD("Skills Auton");
					} else if(nLCDButtons == rightButton){
					waitForRelease();
					currentOption++;
				}
				break;
			case 4:
				displayLCDCenteredString(0, "Disable Auton");
				displayLCDCenteredString(1, "Enter ==>");
				waitForPress();
				if(nLCDButtons == centerButton){
					waitForRelease();
					optionSelected = true;
					autonomousOption = 4;
					clearAndDisplayLCD("Auton Disabled");
					} else if(nLCDButtons == rightButton){
					waitForRelease();
					currentOption = 0;
				}
				break;
			}
		}
		} else {
		displayLCDCenteredString(0, "Auton Disabled");
	}

	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

void boxForward(int power){
	motor[armBox] = 1 * power;
}

void openClaw(int power){
	motor[armClaw] = -1 * power;
	wait1Msec(400);
	motor[armClaw] = 0;
}

void closeClaw(int power){
	motor[armClaw] = power;
}

void armUp(int power){
	motor[Arm_LT_BR] = power;
	motor[Arm_RT_BL] = -1 * power;
}

void armDown(int power){
	motor[Arm_LT_BR] = -1 * power;
	motor[Arm_RT_BL] = power;
}

void moveForwardAuton(int power){
	motor[driveLeft] = power;
	motor[driveRight] = -1 * power;
}

void moveBackwardAuton(int power){
	motor[driveLeft] = -1 * power;
	motor[driveRight] = power;
}

void turnRightAuton(int power){
	motor[driveRight] = power;
	motor[driveLeft] = power;
}

void turnLeftAuton(int power){
	motor[driveRight] = -1 * power;
	motor[driveLeft] = -1 * power;
}

void stopAllMotorsAuton(){
	motor[driveRight] = 0;
	motor[driveLeft] = 0;
	motor[armBox] = 0;
	motor[armClaw] = 0;
	motor[Arm_LT_BR] = 0;
	motor[mogo] = 0;
	motor[Arm_RT_BL] = 0;
}

void mogoDownAuton(){
	motor[mogo] = -127;
	wait1Msec(1250);
	motor[mogo] = 0;
}

void mogoUpAuton(){
	motor[mogo] = 127;
	wait1Msec(1250);
	motor[mogo] = 0;
}

void Left_OR_Right_Auton(bool left){
	// Close the claw so that cone doesn't fall off.
	closeClaw(40);
	// Lift arm
	// Bring the mogo down
	// Move forward to the mobile goal
	armUp(50);
	wait1Msec(250);
	mogoDownAuton();
	// mogoDown waits, no need to add additional wait here
	moveForwardAuton(127);
	wait1Msec(1600);
	stopAllMotorsAuton();

	// Pickup mobile goal
	// Drop the yellow cone on mobile goal
	mogoUpAuton();
	// mogoUp waits, no need to add additional wait here
	armDown(80);
	wait1Msec(750);
	stopAllMotorsAuton();
	// Place the yellow cone on the mobile goal
	openClaw(40);
	stopAllMotorsAuton();

	// Come back straight
	moveBackwardAuton(127);
	wait1Msec(1400);
	stopAllMotorsAuton();
	if (left) {
		turnRightAuton(80);
		} else {
		turnLeftAuton(80);
	}
	wait1Msec(700);
	stopAllMotorsAuton();

	armDown(80);
	wait1Msec(100);

	// Align the back against the fence
	moveBackwardAuton(80);
	wait1Msec(1250);
	stopAllMotorsAuton();

	// Move forward so that there is enough clearence from the fence
	// to turn.
	moveForwardAuton(80);
	wait1Msec(175);
	stopAllMotorsAuton();

	if (left) {
		turnRightAuton(80);
		} else {
		turnLeftAuton(80);
	}
	wait1Msec(425);
	stopAllMotorsAuton();

	moveForwardAuton(127);
	//wait1Msec(650);
	wait1Msec(775);
	stopAllMotorsAuton();

	// Now turn either right or left so that the robot
	// faces the drop zone.
	if (left) {
		turnRightAuton(80);
		} else {
		turnLeftAuton(80);
	}
	wait1Msec(750);
	stopAllMotorsAuton();

	// Lift the arm up
	// Move forward so that robot's front is well within 10 point zone
	// Drop the mobile goal in 20 point zone
	// Drive back a bit
	armUp(80);
	wait1Msec(400);
	stopAllMotorsAuton();
	moveForwardAuton(127);
	wait1Msec(2000);
	mogoDownAuton();
	moveBackwardAuton(127);
	wait1Msec(150);
	stopAllMotorsAuton();
	mogoUpAuton();
	armDown(80);
	wait1Msec(400);
	stopAllMotorsAuton();
	moveBackwardAuton(127);
	wait1Msec(250);
	stopAllMotorsAuton();
}

void Skills() {
	// Run the left auton so that we drop the blue mobile goal
	// in 20 point zone.
	Left_OR_Right_Auton(true);
	wait1Msec(500);

	// Autonomous for picking up Right Red Goal.
	moveForwardAuton(127);
	wait1Msec(200);
	stopAllMotorsAuton();
	// Turn right
	turnRightAuton(80);
	wait1Msec(750);
	stopAllMotorsAuton();
	//go back and use fence to align for the right side mobile goal
	moveBackwardAuton(50);
	wait1Msec(1850);
	stopAllMotorsAuton();

	moveForwardAuton(50);
	wait1Msec(400);
	stopAllMotorsAuton();

	turnRightAuton(50);
	wait1Msec(400);
	stopAllMotorsAuton();

	// Bring the arm up and mogo down while moving forward to pick up the red goal.
	armUp(80);
	wait1Msec(400);
	stopAllMotorsAuton();
	mogoDownAuton();
	moveForwardAuton(80);
	wait1Msec(750);
	stopAllMotorsAuton();
	mogoUpAuton();

	moveBackwardAuton(80);
	wait1Msec(650);
	stopAllMotorsAuton();

	turnLeftAuton(80);
	wait1Msec(850);
	stopAllMotorsAuton();

	moveForwardAuton(80);
	wait1Msec(500);
	stopAllMotorsAuton();
	mogoDownAuton();

	moveBackwardAuton(127);
	wait1Msec(500);
	stopAllMotorsAuton();
}

void staticGoalAuton(){
	//arm up
	armUp(50);
	wait1Msec(1600);
	stopAllMotorsAuton();
	mogoDownAuton();
	//move forward
	moveForwardAuton(80);
	wait1Msec(350);
	stopAllMotorsAuton();
	boxForward(350);
	// waiting to stop cone from shaking
	wait1Msec(3000);
	stopAllMotorsAuton();
	openClaw(80);
	moveBackwardAuton(80);
	wait1Msec(500);
	// Done
	stopAllMotorsAuton();
}

task autonomous(){
	switch(autonomousOption) {
	case 0:
		clearAndDisplayLCD("Left Auton");
		Left_OR_Right_Auton(true /* Left is True */);
		break;
	case 1:
		clearAndDisplayLCD("Right Auton");
		Left_OR_Right_Auton(false /* Left is not True */);
		break;
	case 2:
		clearAndDisplayLCD("Static Auton");
		staticGoalAuton();
		break;
	case 3:
		clearAndDisplayLCD("Skills Auton");
		Skills();
		break;
	case 4:
		clearAndDisplayLCD("Disabled");
		// Disable auton, do nothing.
		break;
	}
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task i s used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/



/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                    User Control Drivetrain functions                      */
/*                                                                           */
/*   All functions for drive train for [Digitron]Team 42627G Digital Minds   */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// Toggle partner variable DO NOT CHANGE
int togglePartner = 1;

/*------------------Dead zone filter------------------------*/



int filter(int input){
	if (input > 20 || input < -20){
		return input;
	}
	else {
		return 0;
	}
}

task toggleTask(){
	while(true){
		if(vexRT[Btn7U] == 1){

			if(togglePartner == 1){
				togglePartner = 0;
				} else {
				togglePartner = 1;
			}

			wait1Msec(700);
		}
	}
}
/*-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_*/

/*------------------------Drive-----------------------------*/
void driveRobot(int forward, int turn) {
	motor[driveRight] = (forward - turn);
	motor[driveLeft] = (forward + turn);
}

task drive(){
	while (true){
		//forward backward
		int forward = togglePartner * filter(vexRT[Ch1Xmtr2]) + (1 - togglePartner) * filter(vexRT[Ch1]);
		//turning
		int turn = togglePartner * filter(vexRT[Ch3Xmtr2]) + (1 - togglePartner) * filter(vexRT[Ch3]);
		driveRobot(forward, turn);
	}
}

/*-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_*/

/*------------------Mobile Goal-----------------------------*/
task mogoLift() {
	while(true){
		//assigning lifting the mobile goal to the upper 8-pad button
		while(vexRT[Btn8UXmtr2] == 1 || vexRT[Btn8U] == 1){
			startMotor(mogo, 80);
		}
		stopMotor(mogo);
		//assigning dropping the mobile goal to the bottom 8-pad button
		while(vexRT[Btn8DXmtr2] == 1 || vexRT[Btn8D] == 1){
			startMotor(mogo, -80);
		}
		stopMotor(mogo);
	}
}

/*-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_*/



/*------------------Arm and claw and boxlift-----------------------------*/

task arm() {
	while(true){
		//assigning lifting the arm to the upper 6-button pad.
		while(vexRT[Btn6U] == 1) {
			startMotor(Arm_LT_BR, 127);
			startMotor(Arm_RT_BL, -127);
		}
		stopMotor(Arm_LT_BR);
		stopMotor(Arm_RT_BL);
		//assigning dropping the arm to the bottom 6-buttom pad.
		while(vexRT[Btn6D] == 1){
			startMotor(Arm_LT_BR, -127);
			startMotor(Arm_RT_BL, 127);
		}
		stopMotor(Arm_LT_BR);
		stopMotor(Arm_RT_BL);
	}
}

//----------------------Arm Box----------------

task box() {
	while(true){
		//box down
		while(vexRT[Btn5U] == 1){
			startMotor(armBox, 127);
		}
		stopMotor(armBox);

		//box up
		while(vexRT[Btn5D] == 1){
			startMotor(armBox, -127);
		}
		stopMotor(armBox);
	}
}

task claw() {
	bool intakeActivated = false;
	bool dropActivated = false;
	while(true){
		//drop cone
		while(vexRT[Btn8R] == 1){
			startMotor(armClaw, 127);
			dropActivated = true;
		}
		if(dropActivated == true){
			stopMotor(armClaw);
			dropActivated = false;
		}
		//intake cone
		while(vexRT[Btn8L] == 1){
			startMotor(armClaw, -127);
			intakeActivated = true;
		}
		if(intakeActivated == true){
			stopMotor(armClaw);
			startMotor(armClaw, -25);
			intakeActivated = false;
		}
		if(vexRT[Btn7D] == 1){
			intakeActivated = false;
			dropActivated = false;
			stopMotor(armClaw);
		}
	}
}


/*-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_*/

//This task drives everything.Don't mess with this unless debugging.
task usercontrol() {
	startTask(toggleTask);
	startTask(drive);
	startTask(mogoLift);
	startTask(arm);
	startTask(box);
	startTask(claw);
}
