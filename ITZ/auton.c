#pragma config(Sensor, dgtl1,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port2,           mogo,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           dl,            tmotorVex393HighSpeed_MC29, openLoop, encoderPort, dgtl1)
#pragma config(Motor,  port4,           TL_BR_Arm,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           roller,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           TR_BL_Arm,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armBox,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           dr,            tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, dgtl3)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX)

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*               Desc: VEX 42627G Team Digital Minds Copyright               */
/*                    						  Credit:																	 */
/*                    Head Developers: Mukul Rao, Jeffrey Tu				         */
/*                                    									                     */
/*                    				                                               */
/*                                                                           */
/*                                                                           */
/*     Filter Function/deadzone filter credit: Kaushik from 315 Paradigm,    */
/*                        as well as some other ideas.                       */
/*---------------------------------------------------------------------------*/


const short RIGHT_BUTTON_LCD = 4;
const short CENTER_BUTTON_LCD = 2;
const short ZONE_20 = 20;
const short ZONE_10 = 10;
const short ZONE_5 = 5;

int autonomousOption = -1;

//Wait for Press----------------------------------------------
void waitForPress()
{
	while(true){
		if(nLCDButtons == RIGHT_BUTTON_LCD || nLCDButtons == CENTER_BUTTON_LCD) {
			break;
		}
	}
	wait1Msec(5);
}
//----------------------------------------------------------------

//Wait for Release------------------------------------------------
void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------

void clearAndDisplayLCD(const char* str) {
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDCenteredString(0, str);
}

void boxForward(int power){
	motor[armBox] = 1 * power;
}

void boxBackward(int power){
	motor[armBox] = -1 * power;
}

void openClaw(int power){
	motor[roller] = -1 * power;
	wait1Msec(400);
	motor[roller] = -10;
}

void closeClaw(int power){
	motor[roller] = power;
}

void armUp(int power){
	motor[TL_BR_Arm] = power;
	motor[TR_BL_Arm] = -1 * power;
}

void armDown(int power){
	motor[TL_BR_Arm] = -1 * power;
	motor[TR_BL_Arm] = power;
}

void moveForwardAuton(int power, int time){
	motor[dl] = power;
	motor[dr] = power;
	wait1Msec(time);
	// Break before stopping completely
	motor[dl] = -25;
	motor[dr] = -25;
	wait1Msec(100);
	motor[dl] = 0;
	motor[dr] = 0;
}

void moveBackwardAuton(int power, int time){
	motor[dl] = -power;
	motor[dr] = -power;
	wait1Msec(time);
	// Break before stopping completely
	motor[dl] = -25;
	motor[dr] = -25;
	wait1Msec(100);
	motor[dl] = 0;
	motor[dr] = 0;
}

void turnRightAuton(int power){
	motor[dr] = -power;
	motor[dl] = power;
}

void turnLeftAuton(int power){
	motor[dr] = power;
	motor[dl] = -power;
}

void stopAllMotorsAuton(){
	motor[dr] = 0;
	motor[dl] = 0;
	motor[armBox] = 0;
	motor[roller] = 0;
	motor[TL_BR_Arm] = 0;
	motor[mogo] = 0;
	motor[TR_BL_Arm] = 0;
}

void mogoDownAuton(){
	motor[mogo] = -127;
	wait1Msec(1250);
	motor[mogo] = 0;
}

void mogoUpAuton(){
	motor[mogo] = 127;
	wait1Msec(1250);
	motor[mogo] = 0;
}

void staticGoalAuton(){
	//Needs to be redone to support new robot
	//arm up
	armUp(50);
	wait1Msec(1600);
	stopAllMotorsAuton();
	//mogoDownAuton();
	//move forward
	moveForwardAuton(80, 625);
	boxForward(127);
	wait1Msec(300);
	stopAllMotorsAuton();
	// waiting to stop cone from shaking
	wait1Msec(500);
	openClaw(80);
	moveBackwardAuton(80, 500);
	boxBackward(127);
	wait1Msec(600);
	stopAllMotorsAuton();
}

void comeBackWithMogoAndTwoCones(bool left) {
	//Needs to be redone to support new robot
	// Close the claw so that cone doesn't fall off.
	closeClaw(40);
	// Lift arm
	// Bring the mogo down
	// Move forward to the mobile goal
	armUp(50);
	wait1Msec(250);
	motor[mogo] = -127;
	// mogoDown waits, no need to add additional wait here
	moveForwardAuton(127, 1675);
	motor[mogo] = 0;
	// Pickup mobile goal
	// Drop the yellow cone on mobile goal
	mogoUpAuton();
	// mogoUp waits, no need to add additional wait here
	armDown(100);
	wait1Msec(750);
	stopAllMotorsAuton();
	// Place the yellow cone on the mobile goal
	openClaw(40);
	stopAllMotorsAuton();

	/*
	if (!left) {
	// Adjust the robot for right jerk
	turnLeftAuton(80);
	wait1Msec(50);
	}
	*/

	// Pick up and stack another cone
	moveForwardAuton(80, 300);
	motor[roller] = -127;
	boxForward(127);
	wait1Msec(400);
	stopMotor(armBox);
	armDown(127);
	wait1Msec(300);
	stopAllMotorsAuton();
	closeClaw(127);
	armUp(80);
	wait1Msec(400);
	stopMotor(TL_BR_Arm);
	stopMotor(TR_BL_Arm);
	boxBackward(127);
	wait1Msec(600);
	stopMotor(armBox);
	armDown(100);
	wait1Msec(450);
	stopAllMotorsAuton();
	// Place the yellow cone on the mobile goal
	openClaw(40);
	stopAllMotorsAuton();

	//
	// Come back straight
	moveBackwardAuton(127, 1350);
}

void dropInTwentyZone(bool left) {
	//Needs to be redone to support new robot
	if (left) {
		turnLeftAuton(80);
		} else {
		turnRightAuton(80);
	}
	wait1Msec(375);

	//coming back after turning towards fence to align with 20 point zone
	stopAllMotorsAuton();

	moveBackwardAuton(127, 800);

	// Now turn either right or left so that the robot
	// faces the drop zone.
	if (left) {
		turnLeftAuton(80);
		} else {
		turnRightAuton(80);
	}
	wait1Msec(600);
	stopAllMotorsAuton();
	// Lift the arm up
	// Move forward so that robot's front is well within 10 point zone
	// Drop the mobile goal in 20 point zone
	// Drive back a bit
	armUp(80);
	wait1Msec(100);
	stopAllMotorsAuton();

	// Keep the claw open!
	motor[roller] = -40;

	//moveForwardAuton(127, 1250);
	motor[dl] = 100;
	motor[dr] = 100;
	//wait1Msec(1250);

	mogoDownAuton();
	moveBackwardAuton(127, 150);
	mogoUpAuton();
	armDown(127);
	wait1Msec(300);
	stopAllMotorsAuton();
	moveBackwardAuton(127, 250);
}

void dropInTenZone(bool left) {
	//Needs to be redone to support new robot
	if (left) {
		turnRightAuton(100);
		} else {
		turnLeftAuton(100);
	}
	if(left){
		wait1Msec(1250);
		} else {
		wait1Msec(1200);
	}
	stopAllMotorsAuton();

	armUp(80);
	wait1Msec(100);
	stopAllMotorsAuton();
	if(left){
		moveForwardAuton(127, 500);
		} else {
		moveForwardAuton(127, 750);
	}
	// Keep the claw open!
	motor[roller] = -40;

	mogoDownAuton();
	moveBackwardAuton(127, 200);
	mogoUpAuton();
	armDown(127);
	wait1Msec(300);
	stopAllMotorsAuton();
	moveBackwardAuton(127, 400);
}

void dropInFiveZone(bool left) {
	//Needs to be redone to support new robot
	if (left) {
		turnRightAuton(80);
		} else {
		turnLeftAuton(80);
	}
	wait1Msec(1400);
	stopAllMotorsAuton();
	moveForwardAuton(80, 200);
	armUp(80);
	wait1Msec(100);
	stopAllMotorsAuton();
	// Keep the claw open!
	motor[roller] = -40;
	mogoDownAuton();
	moveBackwardAuton(127, 150);
	mogoUpAuton();
	armDown(127);
	wait1Msec(300);
	stopAllMotorsAuton();
	moveBackwardAuton(127, 200);
}

void Left_OR_Right_Auton(bool left, short zone){
	//Needs to be redone to support new robot
	comeBackWithMogoAndTwoCones(left);
	switch(zone) {
	case ZONE_20:
		dropInTwentyZone(left);
		break;
	case ZONE_10:
		dropInTenZone(left);
		break;
	case ZONE_5:
		dropInFiveZone(left);
	};
}


task autonomous(){
	//Needs to be redone to support new robot
	switch(autonomousOption) {
	case 0:
		clearAndDisplayLCD("20 Left");
		Left_OR_Right_Auton(true /* Left is True */, ZONE_20);
		break;
	case 1:
		clearAndDisplayLCD("20 Right");
		Left_OR_Right_Auton(false /* Left is not True */, ZONE_20);
		break;
	case 2:
		clearAndDisplayLCD("10 Left");
		Left_OR_Right_Auton(true /* Left is True */, ZONE_10);
		break;
	case 3:
		clearAndDisplayLCD("10 Right");
		Left_OR_Right_Auton(false /* Left is not True */, ZONE_10);
		break;
	case 4:
		clearAndDisplayLCD("5 Left");
		Left_OR_Right_Auton(true /* Left is True */, ZONE_5);
		break;
	case 5:
		clearAndDisplayLCD("5 Right");
		Left_OR_Right_Auton(false /* Left is not True */, ZONE_5);
		break;
	case 6:
		clearAndDisplayLCD("Static Auton");
		staticGoalAuton();
		break;
	case 7:
		clearAndDisplayLCD("Disabled");
		// Disable auton, do nothing.
		break;
	}
}

task usercontrol() {
}

task main(){
	while(vexRT[Btn7R] != 1){
	}
	Left_OR_Right_Auton(true, ZONE_20);
}
